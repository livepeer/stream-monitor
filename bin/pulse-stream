#!/usr/bin/env ruby
require 'rubygems'
require 'bundler/setup'

# setup load path
lib = File.expand_path(File.join(__dir__, "..", "lib"))
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)

require 'streamer/stream'
require 'streamer/livepeer'
require 'streamer/hls_analyzer'
require 'streamer/discord'
require 'securerandom'
require 'logger'
require 'open3'


# Imporant conditions to be exercised:
# - FFMPEG exits earily
# - FFMPEG reaches cycle duration. We have to send a TERM signal to the FFMPEG process
#   which causes the process to exit with 255 code

# Setup APIs
while true
  begin
    duration = 180
    playback_region = ENV.fetch("PLAYBACK_REGION")
    ingest_region = ENV.fetch("INGEST_REGION")
    livepeer = Streamer::Livepeer.new(
      api_key: ENV.fetch("LIVEPEER_API_KEY"),
      host: ENV.fetch("LIVEPEER_API_HOST"),
    )
    discord = Streamer::Discord.new(
      webhook: ENV.fetch("DISCORD_WEBHOOK")
    )
    logger = Logger.new($stdout)
    stream_name = SecureRandom.uuid

    logger.info("Creating stream at #{livepeer.base_url}")
    @stream = livepeer.create_stream(
      name: stream_name,
      profiles: [
         {
          "name": "720p",
          "bitrate": 2000000,
          "fps": 30,
          "width": 1280,
          "height": 720
        },
        {
          "name": "480p",
          "bitrate": 1000000,
          "fps": 30,
          "width": 854,
          "height": 480
        },
        {
          "name": "360p",
          "bitrate": 500000,
          "fps": 30,
          "width": 640,
          "height": 360
        }
      ]
    )
    m3u8 = @stream.playback_url(playback_region)
    logger.info("Created stream. id='#{@stream.id}' key='#{@stream.stream_key}' playback='#{m3u8}'")

    # start broadcast
    command = "ffmpeg"
    ingest = @stream.rtmp_ingest_url(ingest_region)
    logger.info("Starting #{duration}s broadcast to #{ingest}")
    args = [
      "-hide_banner",
      "-re",
      "-fflags",
      "+genpts",
      "-stream_loop",
      "-1",
      "-i",
      "/opt/bbb_30s.ts",
      "-c",
      "copy",
      "-strict",
      "-2",
      "-bsf:a",
      "aac_adtstoasc",
      "-loglevel",
      "repeat+level+warning",
      "-f",
      "flv",
      ingest,
    ]

    logger.info("Executing #{command} #{args.join(" ")}")
    @ffmpeg_pid = nil

    t_ffmpeg = Thread.new do
      @ffmpeg_pid = Process.spawn(command, *args)
      _, @status = Process.wait2(@ffmpeg_pid)
      if @status.exitstatus == 0
        logger.info "FFMPEG completed successfully"
      elsif @status.exitstatus == 255
        logger.info "FFMPEG terminated by signal successfully"
      else
        discord.send(
          content: "FFMPEG exited non-zero when broadcasting to #{ingest} @thedeeno"
        )
        logger.info "FFMPEG exited non-zero"
      end
    end

    t_timer = Thread.new do
      # poll the process every second for the full cycle, exit when no longer there
      duration.times do
        break if !t_ffmpeg.alive?
        sleep 1
      end

      # # process is still running, shut it down
      Process.kill("TERM", @ffmpeg_pid) if t_ffmpeg.alive?
    end

    begin 
      # is ffmpeg still running?
      Process.wait(@ffmpeg_pid, Process::WNOHANG).nil?
    rescue Errno::ECHILD
      logger.error("Process not running")
    ensure
      t_ffmpeg.join
      t_timer.join
    end

    logger.info("Deleting stream #{@stream.id}")
    livepeer.delete_stream(@stream.id)
    logger.info("Deleted stream #{@stream.id}")

  rescue Interrupt
    if @stream
      logger.info("Deleting stream #{@stream.id}")
      livepeer.delete_stream(@stream.id)
      logger.info("Deleted stream #{@stream.id}")
    end
    exit
  rescue TypeError
    if @stream
      logger.info("Deleting stream #{@stream.id}")
      livepeer.delete_stream(@stream.id)
      logger.info("Deleted stream #{@stream.id}")
    end
  end
end
